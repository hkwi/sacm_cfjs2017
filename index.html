<div>
signal_quality <a href="#" onclick="hook_load(17,'signal_quality')">17</a>, <a href="#" onclick="hook_load(19,'signal_quality')">19</a> /
wwan <a href="#" onclick="hook_load(17,'wwan')">17</a>, <a href="#" onclick="hook_load(19,'wwan')">19</a> /
wlan2g <a href="#" onclick="hook_load(17,'wlan2g')">17</a>, <a href="#" onclick="hook_load(19,'wlan2g')">19</a> /
wlan5g <a href="#" onclick="hook_load(17,'wlan5g')">17</a>, <a href="#" onclick="hook_load(19,'wlan5g')">19</a> /
</div>

<style>
.line {
	fill: none;
	stroke: blue;
	stroke-width: 1.5px;
}
</style>

<svg width="900" height="500"></svg>

<script src="d3.min.js"></script>
<script>

var keys = ["dev01","dev02","dev03","dev04","dev05",
	"dev06","dev07","dev08","dev09","dev10"];

var svg = d3.select("svg"),
    margin = {top: 20, right: 20, bottom: 30, left: 50},
    width = svg.attr("width") - margin.left - margin.right,
    height = svg.attr("height") - margin.top - margin.bottom;

var x = d3.scaleTime().range([0, width]),
    y = d3.scaleLinear().range([height, 0]),
    z = d3.scaleOrdinal(d3.schemeCategory10).domain(keys);

var line = d3.line()
	.curve(d3.curveBasis)
	.x(d => x(d.date))
	.y(d => y(d.value));

var g = svg.append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var axis_x = g.append("g")
	.attr("class", "axis axis--x")
	.attr("transform", "translate(0," + height + ")")
	.call(d3.axisBottom(x));

var axis_y = g.append("g")
	.attr("class", "axis axis--y")
	.call(d3.axisLeft(y).ticks(10, "%"));

function hook_load(day, metrics){
	var filename = "cfjs2017_2017-09-"+("00"+day).slice(-2)+".json";
	
	d3.text(filename, function(err, res){
		var ser = res.split("\n").filter(l => l.length > 0).map(function(s){
			var o = JSON.parse(s);
			var d = new Object();
			d.date = d3.isoParse(o["@timestamp"]);
			keys.forEach(function(k){
				d[k] = null;
				if(o[k]){
					if(metrics == "signal_quality"){
						d[k] = o[k]["dialup_device"]["signal_quality"] / 100.0;
					}else if(metrics == "wwan"){
						d[k] = o[k]["interface"]["wwan0"]["in_octets"] + o[k]["interface"]["wwan0"]["out_octets"];
					}else if(metrics == "wlan2g"){
						d[k] = o[k]["wlan_air_time_occupancy"]["2g"]["other"] / 100.0;
					}else if(metrics == "wlan5g"){
						d[k] = o[k]["wlan_air_time_occupancy"]["5g"]["other"] / 100.0;
					}
				}
			});
			return d;
		});
		var data = keys.map(k => ({
			"key": k,
			"values": ser.map(d =>({
				"date": d.date,
				"value": d[k]
			}))
		}));
		
		var start = new Date(2017, 8, day);
		x.domain([start, new Date(start.valueOf()+24*60*60*1000)]);
		axis_x.call(d3.axisBottom(x));
		if(metrics == "signal_quality"){
			y.domain([0, 1]);
			axis_y.call(d3.axisLeft(y).ticks(10, "%"));
		} else if (metrics == "wlan2g" || metrics == "wlan5g"){
			y.domain([0, 0.2]);
			axis_y.call(d3.axisLeft(y).ticks(10, "%"));
		} else {
			console.log([d3.min(data, c=>d3.min(c.values.filter(e=>e.value), d=>d.value)),
				d3.max(data, c=>d3.max(c.values.filter(e=>e.value), d=>d.value))]);
			y.domain([d3.min(data, c=>d3.min(c.values.filter(e=>e.value), d=>d.value)),
				d3.max(data, c=>d3.max(c.values.filter(e=>e.value), d=>d.value))]);
			axis_y.call(d3.axisLeft(y).ticks(10, "s"));
		}
		
		var layer = g.selectAll(".line")
			.data(data)
			.style("stroke", d=>z(d.key)).attr("d", d=>line(d.values));
		layer.enter().append("path").attr("class", "line")
			.style("stroke", d=>z(d.key)).attr("d", d=>line(d.values));
		layer.exit().remove();
	});
}
</script>
